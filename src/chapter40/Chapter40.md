# Chapter40 延迟渲染

[返回](../../README.md)

延迟着色是一种将光照/着色步骤推迟到第二个 **Pass** 处理的技术。
这样做是为了避免对一个像素进行多次着色。基本思路如下:
1. 在第一个 **Pass** 中，渲染场景，但不是计算反射模型，只需存储所有几何体信息(位置、法线、纹理坐标、反射率等)在中间缓冲区集合，统称为 **G** 缓冲区(G代表几何)。
2. 在第二个 **Pass** 中，只需从 **G** 缓冲区读取，计算反射模型，并为每个像素生成最终颜色。

当使用延迟着色时，避免了对那些最终不会可见的片元评估反射模型。
例如，考虑一个位于两个多边形重叠区域的像素。
片元着色器可能会为覆盖该像素的每个多边形各执行一次；
然而，最终只有其中一次执行的结果颜色会成为该像素的最终颜色(假设未启用混合)。
在两个片元中对其中一个进行反射模型评估所消耗的计算周期实际上是浪费的。
使用延迟着色时，反射模型的评估会被推迟，直到所有几何体都处理完成，并且每个像素位置的可见几何体已知。
因此，反射模型只会对屏幕上的每个像素评估一次。
这能够以更高效的方式进行光照计算。
例如，可以使用多达数百个光源，因为只需对每个屏幕像素评估一次光照。

## 40.1 延迟渲染的优缺点

在图形学社区中，延迟着色的相对优缺点一直存在一些争论。
延迟着色并不适用于所有情况。
它在很大程度上取决于应用的具体需求，在决定是否使用延迟着色之前，需要仔细评估其优点和缺点。

**注:** 在最近的 OpenGL 版本中，通过使用 `GL_TEXTURE_2D_MULTISAMPLE`，可以实现具有延迟着色的多样本抗锯齿。

延迟渲染在混合/透明处理方面表现不佳。
使用带有深度剥离的额外缓冲区可以通过在 **G** 缓冲区中存储额外的分层几何信息来提供帮助。

延迟着色的一个显著优点是可以保留第一次渲染的深度信息，并在着色阶段将其作为纹理来访问。
能够将整个深度缓冲作为纹理访问可以实现一些算法，例如景深(深度模糊)、屏幕空间环境光遮蔽、体积粒子以及其他类似技术。

## 40.2 延迟渲染展示

![延迟渲染展示](./images/延迟渲染展示.gif)

[返回](../../README.md)